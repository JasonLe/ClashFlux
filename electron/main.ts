import { app, BrowserWindow, ipcMain, shell } from 'electron'
import path from 'node:path'
import fs from 'node:fs/promises'
import { constants } from 'node:fs'
import { spawn, ChildProcess } from 'node:child_process'
import os from 'node:os'
import { fileURLToPath } from 'node:url'

// === 1. 路径兼容处理 (ESM 模式必须) ===
const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

// === 2. 关键：精准定位 Preload 脚本 ===
// 在开发和生产环境中，vite-plugin-electron/simple 可能会输出 .mjs 或 .js
// 我们这里动态判断一下，或者直接指向构建后的位置
// dist-electron/main.js 和 dist-electron/preload.mjs 通常在同一级
const PRELOAD_PATH = path.join(__dirname, 'preload.mjs')

// === 全局变量 ===
let win: BrowserWindow | null = null;
let kernelProcess: ChildProcess | null = null;

// === 路径定义 ===
const USER_DATA_PATH = app.getPath('userData');
const PROFILES_FILE = path.join(USER_DATA_PATH, 'profiles.json');
const RUNTIME_CONFIG_PATH = path.join(USER_DATA_PATH, 'config.yaml');

// Sidecar 路径逻辑
const IS_DEV = process.env.VITE_DEV_SERVER_URL !== undefined;
const BIN_PATH = IS_DEV
  ? path.join(__dirname, '../sidecars') // 开发环境: dist-electron/../sidecars
  : path.join(process.resourcesPath, 'sidecars'); // 生产环境

const EXECUTABLE_NAME = process.platform === 'win32' ? 'mihomo.exe' : 'mihomo';
const KERNEL_BIN = path.join(BIN_PATH, EXECUTABLE_NAME);

// === 核心配置片段 ===
const FORCE_CONFIG_APPEND = `
# === Auto Generated by Clash Flux ===
external-controller: 127.0.0.1:9097
secret: ""
bind-address: "*"
mixed-port: 7890
port: 0
socks-port: 0
geodata-mode: true
geox-url:
  geoip: "https://testingcf.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/geoip.dat"
  geosite: "https://testingcf.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/geosite.dat"
  mmdb: "https://testingcf.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/country.mmdb"
`;

// === 启动内核 ===
const startKernel = async () => {
  try { await fs.mkdir(USER_DATA_PATH, { recursive: true }); } catch (e) {}

  // 初始化配置
  try {
    await fs.access(RUNTIME_CONFIG_PATH, constants.F_OK);
  } catch {
    console.log('[Init] 初始化默认配置...');
    await fs.writeFile(RUNTIME_CONFIG_PATH, FORCE_CONFIG_APPEND);
  }

  console.log(`[Kernel] Path: ${KERNEL_BIN}`);
  console.log(`[Kernel] Home: ${USER_DATA_PATH}`);

  kernelProcess = spawn(KERNEL_BIN, ['-d', USER_DATA_PATH], {
    cwd: USER_DATA_PATH,
    stdio: 'inherit',
    windowsHide: true
  });
};

const stopKernel = () => {
  if (kernelProcess) {
    kernelProcess.kill();
    kernelProcess = null;
  }
};

async function getClashSecret() {
  try {
    const content = await fs.readFile(RUNTIME_CONFIG_PATH, 'utf-8');
    const match = content.match(/secret:\s*["']?([^"'\s]+)["']?/);
    return match ? match[1] : '';
  } catch (e) { return ''; }
}

// === Service ===
async function ensureConfigFile() {
  try { await fs.access(PROFILES_FILE); } 
  catch { await fs.writeFile(PROFILES_FILE, JSON.stringify([])); }
}
async function readProfiles() {
  await ensureConfigFile();
  const data = await fs.readFile(PROFILES_FILE, 'utf-8');
  return JSON.parse(data);
}
async function saveProfiles(profiles: any[]) {
  await ensureConfigFile();
  await fs.writeFile(PROFILES_FILE, JSON.stringify(profiles, null, 2));
  return true;
}

const createWindow = () => {
  console.log('[Window] Preload Path:', PRELOAD_PATH);

  win = new BrowserWindow({
    width: 1000, height: 720, minWidth: 800, minHeight: 600,
    frame: false, titleBarStyle: 'hidden',
    webPreferences: {
      preload: PRELOAD_PATH, // === 使用修复后的路径 ===
      nodeIntegration: false,
      contextIsolation: true,
    },
  })

  if (process.env.VITE_DEV_SERVER_URL) {
    win.loadURL(process.env.VITE_DEV_SERVER_URL)
  } else {
    win.loadFile('dist/index.html')
  }
}

app.whenReady().then(async () => {
  await startKernel();

  ipcMain.handle('get-clash-secret', getClashSecret);
  ipcMain.handle('get-profiles', readProfiles);
  ipcMain.handle('save-profiles', async (_event, profiles) => saveProfiles(profiles));
  
  ipcMain.handle('download-profile', async (_event, { url, id }) => {
    try {
        const profilePath = path.join(USER_DATA_PATH, `${id}.yaml`);
        console.log(`[Download] ${url}`);
        const res = await fetch(url, { headers: { "User-Agent": "Clash/1.0" } });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        
        let text = await res.text();
        if (!text.includes('proxies:') && /^[A-Za-z0-9+/=]+$/.test(text.trim())) {
          try { text = Buffer.from(text, 'base64').toString('utf-8'); } catch (e) {}
        }
        text = text.replace(/^port:.*$/gm, '# port: removed')
                   .replace(/^socks-port:.*$/gm, '# socks-port: removed')
                   .replace(/^mixed-port:.*$/gm, '# mixed-port: removed')
                   .replace(/^external-controller:.*$/gm, '# external-controller: removed');
        text = text + FORCE_CONFIG_APPEND;

        await fs.writeFile(profilePath, text);
        return { success: true, path: profilePath };
    } catch (e: any) {
        console.error(e);
        throw new Error(e.message);
    }
  });

  ipcMain.on('open-profile-folder', () => shell.openPath(USER_DATA_PATH));
  ipcMain.on('window-min', () => win?.minimize());
  ipcMain.on('window-max', () => win?.isMaximized() ? win.unmaximize() : win?.maximize());
  ipcMain.on('window-close', () => win?.close());
  ipcMain.on('toggle-devtools', () => win?.webContents.toggleDevTools());
  ipcMain.on('open-terminal', () => shell.openPath(os.homedir()));

  createWindow();
})

app.on('before-quit', () => stopKernel());
app.on('window-all-closed', () => { if (process.platform !== 'darwin') app.quit() });